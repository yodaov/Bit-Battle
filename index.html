<!DOCTYPE html>
<html lang="pt-br">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Simulação de Guerras Medievais</title>
<style>
  :root{
    --bg:#0f1115; --panel:#171a21; --panel-2:#0c0f14; --text:#e7edf3; --muted:#9db0c3;
    --ok:#12b886; --danger:#fa5252; --line:#263141; --accent:#3b82f6;
    --table-h: 190px; /* altura da TABELA superior */
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Ubuntu,Arial,sans-serif;}
  header{background:linear-gradient(180deg,var(--panel),var(--panel-2));border-bottom:1px solid var(--line);} 
  h1{margin:0;padding:12px 16px;font-size:18px;letter-spacing:.3px}
  .wrap{display:flex;flex-direction:column;min-height:100vh}

  /* TABELA */
  .table-wrap{height:var(--table-h);padding:10px 12px;overflow:hidden}
  #troop-table{display:grid;grid-template-columns:repeat(14,minmax(90px,1fr));gap:8px;height:100%;}
  .tcell{background:#12151d;border:1px solid #1d2330;border-radius:10px;padding:8px;display:flex;flex-direction:column;align-items:center;justify-content:flex-start;user-select:none;position:relative}
  .tshape{width:44px;height:44px;margin:4px 0 6px 0;display:block}
  .tlabel{font-size:11px;line-height:1.15;text-align:center;color:var(--muted)}
  .tlabel b{color:var(--text)}
  .hint{position:absolute;right:6px;top:4px;font-size:10px;color:#7aa2c0}

  /* ARENA */
  .arena-wrap{position:relative;flex:1;display:flex;flex-direction:column;}
  .arena-topbar{position:absolute;left:0;right:0;top:0;display:flex;justify-content:space-between;pointer-events:none;padding:10px}
  .side-btn{pointer-events:auto;border:none;padding:10px 14px;border-radius:10px;font-weight:600;cursor:pointer;min-width:132px;box-shadow:0 6px 18px rgba(0,0,0,.25);}
  .offensive{background:rgba(18,184,134,.12);color:#a3f2d8;border:1px solid rgba(18,184,134,.35)}
  .defensive{background:rgba(250,82,82,.12);color:#ffb3b3;border:1px solid rgba(250,82,82,.35)}

  #arena{flex:1;background:radial-gradient(1200px 600px at 50% 30%, #0e1320 10%, #0a0e17 60%, #090c14 100%);border-top:1px solid var(--line)}

  /* FOOTER */
  footer{display:flex;justify-content:center;align-items:center;padding:12px;border-top:1px solid var(--line);background:var(--panel)}
  #startBtn{padding:12px 24px;border-radius:12px;border:1px solid #2b3550;background:linear-gradient(180deg,#2a3450,#1b2340);color:#def1ff;font-weight:700;letter-spacing:.3px;cursor:pointer;box-shadow:0 8px 25px rgba(0,0,0,.35)}
  #startBtn.playing{background:linear-gradient(180deg,#0b3d18,#073013);border-color:#0c6b37}

  /* OVERLAY DE FIM */
  .overlay{position:absolute;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.45);backdrop-filter:blur(2px)}
  .overlay .card{background:#101522;border:1px solid #202a40;border-radius:14px;padding:18px 20px;min-width:320px;text-align:center;box-shadow:0 10px 30px rgba(0,0,0,.45)}
  .overlay h2{margin:0 0 8px 0}
  .overlay p{margin:0 0 14px 0;color:var(--muted)}
  .overlay button{padding:10px 16px;border-radius:10px;border:1px solid #31406a;background:#162042;color:#dfe9ff;font-weight:600;cursor:pointer}

  /* Drag shape canvas overlay */
  #dragCanvas{position:fixed;left:0;top:0;pointer-events:none;z-index:40}

  /* Responsivo simples */
  @media (max-width:1200px){
    #troop-table{grid-template-columns:repeat(7,minmax(90px,1fr));}
  }
  .credit{position:absolute;right:12px;bottom:12px;font-size:12px;color:#7aa2c0;opacity:.7;pointer-events:none}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>Simulação de Guerras Medievais — Arraste tropas da <b>Tabela</b> para a <b>Arena</b> (esquerda ou direita)</h1>
  </header>

  <div class="table-wrap">
    <div id="troop-table"></div>
  </div>

  <div class="arena-wrap">
    <canvas id="arena"></canvas>
    <div class="arena-topbar">
      <button id="leftMode" class="side-btn offensive" aria-pressed="true">Ofensivo (Esquerda)</button>
      <button id="rightMode" class="side-btn offensive" aria-pressed="true">Ofensivo (Direita)</button>
    </div>
    <div class="credit">yodaov</div>
    <div id="endOverlay" class="overlay">
      <div class="card">
        <h2 id="endTitle">Fim de batalha</h2>
        <p id="endSubtitle">—</p>
        <button id="resetBtn">Recomeçar</button>
      </div>
    </div>
  </div>

  <footer>
    <button id="startBtn">Começar</button>
  </footer>
</div>

<canvas id="dragCanvas" width="1" height="1"></canvas>

<script>
// ======= DEFINIÇÕES DAS TROPAS =======
const BASE_SIZE = 16; // px
const SPEED = 70;     // velocidade base px/s
const JITTER = 0.0005; // ruído mínimo p/ evitar pendular

// Definição por tipo
// shape: 'square' | 'triangle' | 'circle' | 'pentagon'
const TYPES = [
  { id:'soldado',      name:'Soldado',       color:'#ff3b30', shape:'square',   sizeMul:1,  hp:10, dmg:5,  atkEvery:2,  rangeMul:0,   melee:true },
  { id:'arqueiro',     name:'Arqueiro',      color:'#ffd43b', shape:'triangle', sizeMul:1,  hp:10, dmg:10, atkEvery:6,  rangeMul:20,  melee:false },
  { id:'arqueiroElite',name:'Arqueiro elite',color:'#1b5e20', shape:'triangle', sizeMul:1,  hp:10, dmg:15, atkEvery:4,  rangeMul:30,  melee:false },
  { id:'guerreiro',    name:'Guerreiro',     color:'#515151', shape:'square',   sizeMul:1,  hp:22, dmg:10, atkEvery:3,  rangeMul:0,   melee:true },
  { id:'scutum',       name:'Scutum',        color:'#ff3b30', shape:'circle',   sizeMul:1,  hp:35, dmg:2,  atkEvery:3,  rangeMul:0,   melee:true },
  { id:'lanceiro',     name:'Lanceiro',      color:'#ff922b', shape:'square',   sizeMul:1,  hp:5, dmg:20,  atkEvery:4,  rangeMul:5,   melee:false },
  { id:'elefante',     name:'Elefante',      color:'#8C8C8C', shape:'circle',   sizeMul:2,  hp:250, dmg:40, atkEvery:3.5,  rangeMul:0,   melee:true },
  { id:'mosqueteiro',  name:'Mosqueteiro',   color:'#1D44B8', shape:'circle',   sizeMul:1,  hp:10, dmg:60, atkEvery:15, rangeMul:25,  melee:false },
  { id:'general',      name:'General',       color:'#FFD700', shape:'pentagon', sizeMul:1,  hp:40, dmg:20, atkEvery:1.5,  rangeMul:0,   melee:true },
  { id:'canhoneiro',   name:'Canhoneiro',    color:'#000000', shape:'square',   sizeMul:1,  hp:20, dmg:300,atkEvery:25, rangeMul:35,  melee:false, speedMul:0.5 },
  { id:'armaEspada',   name:'Arma-espada',   color:'#7ec8e3', shape:'triangle', sizeMul:1,  hp:10, dmg:60, atkEvery:20, rangeMul:20,  melee:false, phase:'mosqueteiro' },
  { id:'viking',       name:'Viking',        color:'#7a5230', shape:'square',   sizeMul:1,  hp:5,  dmg:15, atkEvery:1,  rangeMul:0,   melee:true },
  { id:'cavalariaLeve',  name:'Cavalaria leve',  color:'#8B5A2B', shape:'triangle', sizeMul:1,  hp:20, dmg:10, atkEvery:3,  rangeMul:0, melee:true, speedMul:2,   isCavalry:true },
  { id:'cavalariaPesada', name:'Cavalaria pesada', color:'#707070', shape:'triangle', sizeMul:1,  hp:25, dmg:15, atkEvery:4,  rangeMul:0, melee:true, speedMul:1.5, isCavalry:true }
];

// Soldado stats para arma-espada fase 2
const SOLDIER_STATS = { hp:10, dmg:5, atkEvery:2, rangeMul:0, melee:true };

// ======= SISTEMA =======
const arena = document.getElementById('arena');
const ctx = arena.getContext('2d');
const dragCanvas = document.getElementById('dragCanvas');
const dctx = dragCanvas.getContext('2d');
const table = document.getElementById('troop-table');
const startBtn = document.getElementById('startBtn');
const leftModeBtn = document.getElementById('leftMode');
const rightModeBtn = document.getElementById('rightMode');
const endOverlay = document.getElementById('endOverlay');
const endTitle = document.getElementById('endTitle');
const endSubtitle = document.getElementById('endSubtitle');
const resetBtn = document.getElementById('resetBtn');

let state = {
  started:false,
  lastTime:0,
  w:0,h:0,
  leftOffensive:true,
  rightOffensive:true,
  units:[], // {id,x,y,vx,vy,team,typeRef,rad,hp,maxHp,dmg,atkEvery,range,melee,cooldown,dead,fade,phase}
  projectiles:[], // efeitos visuais simples (linhas curtas)
};

let drag = {
  active:false, type:null, x:0, y:0
};
let nextUnitId = 1;

function resize(){
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  const rect = arena.getBoundingClientRect();
  state.w = rect.width; state.h = rect.height;
  arena.width = Math.floor(rect.width * dpr);
  arena.height = Math.floor(rect.height * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize', resize);

// Construir TABELA de tropas
function buildTable(){
  table.innerHTML = '';
  TYPES.forEach(t => {
    const cell = document.createElement('div');
    cell.className = 'tcell';
    const canv = document.createElement('canvas');
    canv.width = 44; canv.height = 44; canv.className='tshape';
    drawShape(canv.getContext('2d'), 22,22, BASE_SIZE*t.sizeMul*0.9, t.shape, t.color);

    const lab = document.createElement('div'); lab.className='tlabel';
    lab.innerHTML = `<b>${t.name}</b><br>Vida ${t.hp} • Dano ${t.dmg}`;

    cell.appendChild(canv);
    cell.appendChild(lab);

    // tornar "arrastável" (nosso próprio DnD)
    cell.addEventListener('pointerdown', e=>startDrag(e,t));

    table.appendChild(cell);
  });
}

// Desenhar formas no canvas
function drawShape(g, cx, cy, size, shape, color){
  g.save();
  g.fillStyle = color; g.strokeStyle = '#ffffff25'; g.lineWidth = 1.5;
  if(shape==='square'){
    g.beginPath(); g.rect(cx-size, cy-size, size*2, size*2); g.fill(); g.stroke();
  }else if(shape==='circle'){
    g.beginPath(); g.arc(cx,cy,size,0,Math.PI*2); g.fill(); g.stroke();
  }else if(shape==='triangle'){
    const h = size*1.6; // um triângulo um pouco alto
    g.beginPath();
    g.moveTo(cx, cy-h/2);
    g.lineTo(cx-size, cy+h/2);
    g.lineTo(cx+size, cy+h/2);
    g.closePath(); g.fill(); g.stroke();
  }else if(shape==='pentagon'){
    g.beginPath();
    const n=5; const r=size; const rot=-Math.PI/2;
    for(let i=0;i<n;i++){
      const a = rot + i*2*Math.PI/n;
      const x = cx + Math.cos(a)*r;
      const y = cy + Math.sin(a)*r;
      if(i===0) g.moveTo(x,y); else g.lineTo(x,y);
    }
    g.closePath(); g.fill(); g.stroke();
  }
  g.restore();
}

function startDrag(e, type){
  drag.active = true; drag.type = type; 
  drag.x = e.clientX; drag.y = e.clientY; 
  if(e.target.setPointerCapture){ try{ e.target.setPointerCapture(e.pointerId); }catch(err){} }
  dragCanvas.style.display = 'block';
  updateDragCanvas();
  window.addEventListener('pointermove', onDragMove);
  window.addEventListener('pointerup', onDragEnd, {once:true});
}
function onDragMove(e){ drag.x = e.clientX; drag.y = e.clientY; updateDragCanvas(); }
function updateDragCanvas(){
  if(!drag.active || !drag.type) { dragCanvas.style.display='none'; dragCanvas.width=1; dragCanvas.height=1; return; }
  const size = BASE_SIZE*drag.type.sizeMul*1.2;
  dragCanvas.width = size*2+6; dragCanvas.height = size*2+6;
  // posição absoluta na viewport (elemento position:fixed)
  dragCanvas.style.transform = `translate(${drag.x - size - 3}px, ${drag.y - size - 3}px)`;
  const g = dctx; g.clearRect(0,0,dragCanvas.width,dragCanvas.height);
  drawShape(g, dragCanvas.width/2, dragCanvas.height/2, size, drag.type.shape, drag.type.color);
}
function onDragEnd(e){
  window.removeEventListener('pointermove', onDragMove);
  // Verificar se soltou dentro da ARENA
  const aRect = arena.getBoundingClientRect();
  if(e.clientY >= aRect.top && e.clientY <= aRect.bottom){
    const x = e.clientX - aRect.left; const y = e.clientY - aRect.top;
    const team = (x < aRect.width/2) ? 'left' : 'right';
    spawnUnit(team, x, y, drag.type);
  }
  drag.active=false; drag.type=null; dragCanvas.style.display='none'; updateDragCanvas();
}

function spawnUnit(team, x, y, t){
  const rad = BASE_SIZE * t.sizeMul;
  const u = {
    id: nextUnitId++, team, x, y, vx:0, vy:0,
    typeRef: t, rad, color: t.color, shape: t.shape,
    hp: t.hp, maxHp:t.hp, dmg: t.dmg, atkEvery: t.atkEvery, range: t.rangeMul*BASE_SIZE, melee: t.melee,
    cooldown: 0, dead:false, fade:0, targetId:null, lastDist:null, noProgressT:0, phase:t.phase||null,
    speedMul: t.speedMul || 1, isCavalry: !!t.isCavalry, accelElapsed: 0,
    // mira
    aiming:false, aimTimer:0, prevInRange:false, wasMoving:false
  };
  // Pequena nudged para evitar sobreposição forte no spawn
  const jitter = (Math.random()-.5)*4;
  u.x += jitter; u.y += jitter;
  state.units.push(u);
}

// ======= BOTÕES =======
leftModeBtn.addEventListener('click', ()=>{
  state.leftOffensive = !state.leftOffensive;
  applyModeBtn(leftModeBtn, state.leftOffensive, 'Esquerda');
});
rightModeBtn.addEventListener('click', ()=>{
  state.rightOffensive = !state.rightOffensive;
  applyModeBtn(rightModeBtn, state.rightOffensive, 'Direita');
});
function applyModeBtn(btn, isOff, sideText){
  btn.classList.toggle('offensive', isOff);
  btn.classList.toggle('defensive', !isOff);
  btn.setAttribute('aria-pressed', String(isOff));
  btn.textContent = (isOff? 'Ofensivo':'Defensivo') + ` (${sideText})`;
}

startBtn.addEventListener('click', ()=>{
  if(!state.started){
    state.started = true; startBtn.classList.add('playing'); startBtn.textContent='Em batalha';
  }
});
resetBtn.addEventListener('click', resetBattle);

function resetBattle(){
  endOverlay.style.display='none';
  state.units.length=0; state.projectiles.length=0;
  state.started=false; startBtn.classList.remove('playing'); startBtn.textContent='Começar';
  state.leftOffensive=true; state.rightOffensive=true;
  applyModeBtn(leftModeBtn,true,'Esquerda');
  applyModeBtn(rightModeBtn,true,'Direita');
}

// ======= Auxílio: tempo de mira por tipo =======
function getAimDelay(u){
  const id = u.typeRef.id;
  if(id==='lanceiro') return 0; // não precisa mirar
  if(id==='mosqueteiro' || id==='canhoneiro') return 1.5;
  if(id==='armaEspada' && !u.melee) return 1.5; // fase mosqueteiro
  if(id==='arqueiro') return 0.8;
  if(id==='arqueiroElite') return 0.4; // versão principal
  return 0;
}

// ======= GAME LOOP =======
function loop(ts){
  if(!state.lastTime) state.lastTime = ts;
  const dt = Math.min(0.05, (ts - state.lastTime)/1000); // cap dt
  state.lastTime = ts;

  update(dt);
  render();
  requestAnimationFrame(loop);
}

function update(dt){
  // Não mover tropas antes do começo
  if(state.started){
    thinkTargets(dt);
    physics(dt);
    combat(dt);
    cleanup();
    checkEnd();
  }
}

function thinkTargets(dt){
  // Atualiza alvo mais próximo periodicamente
  for(const u of state.units){ if(u.dead) continue;
    // se não há inimigos, fica sem target
    const enemies = state.units.filter(v=>!v.dead && v.team!==u.team);
    if(enemies.length===0){ u.targetId=null; continue; }
    // Escolher alvo mais próximo
    let best=null, bestD=Infinity;
    for(const v of enemies){
      const dx=v.x-u.x, dy=v.y-u.y; const d = Math.hypot(dx,dy);
      if(d<bestD){ best=v; bestD=d; }
    }
    u.targetId = best? best.id : null;
  }
}

function physics(dt){
  // Movimento com steering (seek + separation) e resolução de colisão
  // 1) Integração de velocidade
  for(const u of state.units){ if(u.dead) continue;
    const target = state.units.find(v=>v.id===u.targetId);
    // capturar movimento do frame anterior para decidir mira
    u.wasMoving = Math.hypot(u.vx,u.vy) > 0.5;

    const isOffensive = (u.team==='left') ? state.leftOffensive : state.rightOffensive;

    let desiredX=0, desiredY=0;
    if(isOffensive && target){
      // Checar alcance
      const dx = target.x - u.x; const dy = target.y - u.y; const dist = Math.hypot(dx,dy);
      const inRange = u.melee ? (dist <= u.rad + target.rad + 1.5) : (dist <= u.range);

      // Cavalaria: acumula aceleração por até 3s enquanto avança e está fora do alcance
      if(u.isCavalry){
        if(isOffensive && !inRange){
          u.accelElapsed = Math.min(3, (u.accelElapsed||0) + dt);
        }
      }

      // Lógica de mira (apenas para unidades com delay de mira)
      const aimDelay = getAimDelay(u);
      if(aimDelay>0){
        const moving = u.wasMoving; // usar velocidade do frame anterior
        if(inRange){
          if(!u.prevInRange && moving && u.cooldown<=0 && !u.aiming){
            u.aiming = true; u.aimTimer = aimDelay; u.vx = 0; u.vy = 0; // parar imediatamente
          }
        } else {
          // saiu do alcance: cancela mira
          u.aiming = false; u.aimTimer = 0;
        }
      }

      if(!inRange && !u.aiming){
        // vetor em direção ao alvo
        if(dist>0.0001){ desiredX += dx/dist; desiredY += dy/dist; }
      }
      // Progresso para não ficar preso
      if(u.lastDist==null) u.lastDist = dist;
      if(dist < u.lastDist - 0.5) { u.noProgressT=0; } else { u.noProgressT += dt; }
      u.lastDist = dist;
      if(u.noProgressT > 1.2 && isOffensive && !u.aiming){ // tentar escapar
        // adicionar componente lateral
        const perpX = -dy/(dist||1), perpY = dx/(dist||1);
        const side = (Math.random()<0.5? -1:1);
        desiredX += perpX*0.8*side; desiredY += perpY*0.8*side; 
        u.noProgressT = 0.6; // reduz e tenta de novo
      }

      // marcar estado de alcance p/ próximo frame
      u.prevInRange = inRange;
    }

    // separação para evitar engarrafamentos
    let sepX=0, sepY=0; let wn=0;
    for(const v of state.units){ if(v===u || v.dead) continue; 
      const dx=u.x-v.x, dy=u.y-v.y; const d=Math.hypot(dx,dy); const minD=u.rad+v.rad+2;
      if(d<minD && d>0.0001){
        const isEle = u.typeRef.id==='elefante';
        const otherEle = v.typeRef.id==='elefante';
        const push=(minD-d)/minD;
        const w = isEle ? 0 : (otherEle ? 1.8 : 1);
        sepX += (dx/d)*push*w; sepY += (dy/d)*push*w; wn += w;
      }
    }
    if(wn>0){ sepX/=wn; sepY/=wn; }

    // Combinar (se está mirando, parar o movimento voluntário; manter separação)
    let vx = (u.aiming? 0 : desiredX*1.0) + sepX*1.6; 
    let vy = (u.aiming? 0 : desiredY*1.0) + sepY*1.6;

    // Normalizar
    const mag = Math.hypot(vx,vy) + JITTER;
    const baseMul = (u.rad/BASE_SIZE <= 1 ? 1 : 0.7);
    const accelFactor = u.isCavalry
      ? (1 + ((u.speedMul||1) - 1) * Math.min(1, (u.accelElapsed||0)/3))
      : (u.speedMul || 1);
    const maxV = SPEED * baseMul * accelFactor; // elefante mais lento
    let tx = vx/mag * maxV; let ty = vy/mag * maxV;

    // amortecimento suave para movimento natural; freia mais quando mirando
    const smooth = u.aiming ? 0.35 : 0.14;
    if(!state.started || !( (u.team==='left'?state.leftOffensive:state.rightOffensive) )){ tx=0; ty=0; }
    u.vx = u.vx*(1-smooth) + tx*smooth;
    u.vy = u.vy*(1-smooth) + ty*smooth;
  }

  // 2) Atualizar posição
  for(const u of state.units){ if(u.dead) continue; u.x += u.vx*dt; u.y += u.vy*dt; }

  // 3) Resolver colisões de sobreposição (empurrão) — não atravessar
  for(let i=0;i<state.units.length;i++){
    const a=state.units[i]; if(a.dead) continue;
    for(let j=i+1;j<state.units.length;j++){
      const b=state.units[j]; if(b.dead) continue;
      let dx=b.x-a.x, dy=b.y-a.y; let d=Math.hypot(dx,dy);
      const minD = a.rad + b.rad + 0.5;
      if(d<minD && d>0){
        const overlap = (minD-d)/2;
        const nx = dx/d, ny = dy/d;
        let moveA = 0.5, moveB = 0.5;
        const aEle = a.typeRef.id==='elefante';
        const bEle = b.typeRef.id==='elefante';
        if(aEle && !bEle){ moveA = 0; moveB = 1; }
        else if(bEle && !aEle){ moveA = 1; moveB = 0; }
        a.x -= nx*overlap*2*moveA; a.y -= ny*overlap*2*moveA;
        b.x += nx*overlap*2*moveB; b.y += ny*overlap*2*moveB;
      }
    }
  }

  // 4) Limites da arena
  const pad = 6;
  for(const u of state.units){ if(u.dead) continue;
    u.x = Math.max(pad+u.rad, Math.min(state.w - pad - u.rad, u.x));
    u.y = Math.max(12+u.rad, Math.min(state.h - pad - u.rad, u.y));
  }
}

function combat(dt){
  for(const u of state.units){ if(u.dead) continue;
    if(u.cooldown>0) u.cooldown -= dt;
    const target = state.units.find(v=>v.id===u.targetId);
    // capturar movimento do frame anterior para decidir mira (fallback)
    u.wasMoving = Math.hypot(u.vx,u.vy) > 0.5;
    if(!target || target.dead) continue;
    const dx = target.x - u.x; const dy = target.y - u.y; const dist = Math.hypot(dx,dy);
    const inRange = u.melee ? (dist <= u.rad + target.rad + 1.5) : (dist <= u.range);

    // Se está mirando, conta o tempo e ainda não ataca
    const aimDelay = getAimDelay(u);
    const enteringNow = inRange && !u.prevInRange;
    if(aimDelay>0){
      if(!inRange){ u.aiming=false; u.aimTimer=0; }
      // fallback: se entrou no alcance neste frame e estava andando, inicia mira aqui também
      if(!u.aiming && enteringNow && u.wasMoving && u.cooldown<=0){
        u.aiming = true; u.aimTimer = aimDelay;
      }
      if(u.aiming){ u.aimTimer -= dt; if(u.aimTimer>0) continue; else u.aiming=false; }
    }

    if(inRange && u.cooldown<=0){
      if(u.typeRef.id==='elefante'){
        // Elefante: golpear até 2 inimigos no alcance melee
        const enemies = state.units.filter(v=>!v.dead && v.team!==u.team);
        const within = enemies.filter(v=> Math.hypot(v.x-u.x, v.y-u.y) <= u.rad + v.rad + 1.5)
                               .sort((a,b)=> Math.hypot(a.x-u.x, a.y-u.y) - Math.hypot(b.x-u.x, b.y-u.y));
        const toHit = within.slice(0,2);
        for(const t of toHit){ t.hp -= u.dmg; if(t.hp<=0 && !t.dead){ t.dead=true; t.fade=0.8; t.vx=0; t.vy=0; } }
        u.cooldown = u.atkEvery;
      } else if(u.typeRef.id==='armaEspada' && u.phase!=='soldado' && !u.melee){
        // Arma-espada: primeiro ataque à distância, depois vira soldado (melee)
        target.hp -= u.dmg;
        state.projectiles.push({x1:u.x, y1:u.y, x2:target.x, y2:target.y, t:0.18, color:'#a7d3ff'});
        u.dmg = SOLDIER_STATS.dmg;
        u.atkEvery = SOLDIER_STATS.atkEvery;
        u.range = 0;
        u.melee = true;
        u.phase = 'soldado';
        u.cooldown = SOLDIER_STATS.atkEvery;
      } else {
        // ataque normal (inclui cavalaria com multiplicador ao terminar aceleração)
        let _d = u.dmg;
        if(u.isCavalry){
          // multiplicador baseado no tempo acelerando antes do contato (1x..3x)
          const mult = Math.max(1, Math.min(3, Math.ceil(u.accelElapsed||0)));
          _d *= mult;
          // após golpear, zera aceleração acumulada
          u.accelElapsed = 0;
        }
        target.hp -= _d;
        u.cooldown = u.atkEvery;
        if(!u.melee){
          state.projectiles.push({x1:u.x, y1:u.y, x2:target.x, y2:target.y, t:0.18, color:'#a7d3ff'});
        }
      }
      if(target.hp<=0 && !target.dead){ target.dead=true; target.fade=0.8; target.vx=0; target.vy=0; }
    }
  }

  // atualizar efeitos de projéteis
  state.projectiles = state.projectiles.filter(p=> (p.t-=dt) > 0);

  // fade de mortos
  for(const u of state.units){ if(!u.dead) continue; u.fade -= dt; }
}

function cleanup(){
  // Remover completamente os que sumiram
  state.units = state.units.filter(u=> !(u.dead && u.fade<=0));
}

function checkEnd(){
  const leftAlive = state.units.some(u=>!u.dead && u.team==='left');
  const rightAlive = state.units.some(u=>!u.dead && u.team==='right');
  if(!leftAlive || !rightAlive){
    const winner = leftAlive? 'Esquerda' : rightAlive? 'Direita' : 'Empate';
    endTitle.textContent = `Vitória: ${winner}`;
    const l = state.units.filter(u=>u.team==='left').length;
    const r = state.units.filter(u=>u.team==='right').length;
    endSubtitle.textContent = `Unidades restantes — Esquerda: ${l} • Direita: ${r}`;
    endOverlay.style.display='flex';
  }
}

function render(){
  ctx.clearRect(0,0,state.w,state.h);
  // linha central
  ctx.save();
  ctx.strokeStyle = '#21304a'; ctx.lineWidth = 2; ctx.setLineDash([8,8]);
  ctx.beginPath(); ctx.moveTo(state.w/2, 0); ctx.lineTo(state.w/2, state.h); ctx.stroke();
  ctx.restore();

  // desenhar unidades (mortos no fundo com alpha menor)
  const sorted = [...state.units].sort((a,b)=> (a.dead?0:1)-(b.dead?0:1));
  for(const u of sorted){
    const alpha = u.dead ? Math.max(0,u.fade) : 1;
    ctx.save(); ctx.globalAlpha = alpha;
    drawShape(ctx, u.x, u.y, u.rad, u.shape, u.color);
    // barra de vida
    if(!u.dead){
      const w = u.rad*1.8; const h=4; const x=u.x-w/2, y=u.y+u.rad+6;
      ctx.fillStyle='#0b1220'; ctx.fillRect(x,y,w,h);
      ctx.fillStyle='#1dd1a1'; ctx.fillRect(x,y,w*(u.hp/Math.max(1,u.maxHp)),h);
      ctx.strokeStyle='#00000055'; ctx.strokeRect(x,y,w,h);
    }
    ctx.restore();
  }

  // projéteis (linhas rápidas)
  for(const p of state.projectiles){
    ctx.save(); ctx.globalAlpha = Math.max(0,p.t/0.18);
    ctx.strokeStyle = p.color; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(p.x1,p.y1); ctx.lineTo(p.x2,p.y2); ctx.stroke(); ctx.restore();
  }
}

// ======= TESTES (não interferem na jogabilidade) =======
function runUnitTests(){
  const save = { started: state.started, units: state.units, projectiles: state.projectiles, leftOffensive: state.leftOffensive, rightOffensive: state.rightOffensive };
  state.started = true; state.units = []; state.projectiles = [];
  console.group("Tests");
  try{
    // Teste 1: spawnUnit cria unidade correta
    const before = state.units.length;
    spawnUnit('left', 100, 100, TYPES.find(t=>t.id==='soldado'));
    console.assert(state.units.length === before+1, 'spawnUnit deve adicionar 1 unidade');
    // cleanup parcial
    state.units.pop();

    // Teste 2: Arma-espada converte para soldado após primeiro ataque (sem mira, pois está parado)
    spawnUnit('left', 120, 120, TYPES.find(t=>t.id==='armaEspada'));
    spawnUnit('right', 240, 120, TYPES.find(t=>t.id==='soldado'));
    thinkTargets(0.016);
    for(const u of state.units){ u.cooldown = 0; u.vx=0; u.vy=0; } // parado: não deve aplicar delay de mira
    combat(0.016);
    const arma = state.units.find(u=>u.typeRef.id==='armaEspada');
    console.assert(arma && arma.melee && arma.phase==='soldado' && arma.dmg===SOLDIER_STATS.dmg, 'Arma-espada deve virar soldado após primeiro tiro');
    state.units.length = 0;

    // Teste 3: Cavalaria leve acumula aceleração e aplica multiplicador 2× no primeiro golpe após ~2s
    spawnUnit('left', 100, 100, TYPES.find(t=>t.id==='cavalariaLeve'));
    spawnUnit('right', 400, 100, TYPES.find(t=>t.id==='scutum'));
    thinkTargets(0.016);
    // Simular ~2.1s de movimento para acumular aceleração
    for(let i=0;i<140;i++){ physics(0.015); }
    // Colocar em alcance corpo-a-corpo forçando aproximação imediata
    const cav = state.units[0]; const target = state.units[1];
    cav.x = target.x - (cav.rad + target.rad) + 1; cav.y = target.y; cav.cooldown = 0;
    thinkTargets(0.016); combat(0.016);
    const expected = 35 - (10*2); // Scutum 35 HP, cav leve 10 dmg * 2x
    console.assert(target.hp === expected, 'Cavalaria leve deve causar 2x dano após ~2s de aceleração');
    state.units.length = 0;

    // Teste 4: Mosqueteiro em movimento deve esperar ~1.5s ao entrar no alcance
    state.leftOffensive = true; state.rightOffensive = false; // alvo parado
    spawnUnit('left', 100, 120, TYPES.find(t=>t.id==='mosqueteiro'));
    spawnUnit('right', 420, 120, TYPES.find(t=>t.id==='scutum'));
    thinkTargets(0.016);
    let entered=false; let shooter = state.units[0]; let tgt = state.units[1];
    for(let i=0;i<200 && !entered;i++){ physics(0.05); const d=Math.hypot(tgt.x-shooter.x,tgt.y-shooter.y); if(d <= shooter.range){ entered=true; shooter.cooldown=0; break; } }
    const hp0 = tgt.hp;
    // antes de 1.5s não deve causar dano
    for(let t=0;t<1.4;t+=0.1){ combat(0.1); }
    console.assert(tgt.hp === hp0, 'Mosqueteiro não deve atirar antes de ~1.5s de mira');
    combat(0.25);
    const mosqD = TYPES.find(t=>t.id==='mosqueteiro').dmg;
    console.assert(tgt.hp === hp0-mosqD, 'Mosqueteiro deve causar dano após ~1.5s de mira');
    state.units.length = 0;

    // Teste 5: Arqueiro em movimento espera ~0.8s
    state.leftOffensive = true; state.rightOffensive = false;
    spawnUnit('left', 100, 120, TYPES.find(t=>t.id==='arqueiro'));
    spawnUnit('right', 400, 120, TYPES.find(t=>t.id==='scutum'));
    thinkTargets(0.016);
    shooter = state.units[0]; tgt = state.units[1]; entered=false;
    for(let i=0;i<200 && !entered;i++){ physics(0.05); const d=Math.hypot(tgt.x-shooter.x,tgt.y-shooter.y); if(d <= shooter.range){ entered=true; shooter.cooldown=0; break; } }
    const hpA0 = tgt.hp;
    for(let t=0;t<0.7;t+=0.1){ combat(0.1); }
    console.assert(tgt.hp === hpA0, 'Arqueiro não deve atirar antes de ~0.8s');
    combat(0.2);
    console.assert(tgt.hp === hpA0-10, 'Arqueiro deve atirar após ~0.8s');
    state.units.length = 0;

    // Teste 6: Arqueiro elite em movimento espera ~0.4s
    state.leftOffensive = true; state.rightOffensive = false;
    spawnUnit('left', 100, 120, TYPES.find(t=>t.id==='arqueiroElite'));
    spawnUnit('right', 400, 120, TYPES.find(t=>t.id==='scutum'));
    thinkTargets(0.016);
    shooter = state.units[0]; tgt = state.units[1]; entered=false;
    for(let i=0;i<200 && !entered;i++){ physics(0.05); const d=Math.hypot(tgt.x-shooter.x,tgt.y-shooter.y); if(d <= shooter.range){ entered=true; shooter.cooldown=0; break; } }
    const hpE0 = tgt.hp;
    for(let t=0;t<0.3;t+=0.1){ combat(0.1); }
    console.assert(tgt.hp === hpE0, 'Arqueiro elite não deve atirar antes de ~0.4s');
    combat(0.2);
    console.assert(tgt.hp === hpE0-15, 'Arqueiro elite deve atirar após ~0.4s');
    state.units.length = 0;

    // Teste 7: Canhoneiro em movimento espera ~1.5s
    state.leftOffensive = true; state.rightOffensive = false;
    spawnUnit('left', 100, 120, TYPES.find(t=>t.id==='canhoneiro'));
    spawnUnit('right', 420, 120, TYPES.find(t=>t.id==='scutum'));
    thinkTargets(0.016);
    shooter = state.units[0]; tgt = state.units[1]; entered=false;
    for(let i=0;i<240 && !entered;i++){ physics(0.05); const d=Math.hypot(tgt.x-shooter.x,tgt.y-shooter.y); if(d <= shooter.range){ entered=true; shooter.cooldown=0; break; } }
    const hpC0 = tgt.hp;
    for(let t=0;t<1.4;t+=0.1){ combat(0.1); }
    console.assert(tgt.hp === hpC0, 'Canhoneiro não deve atirar antes de ~1.5s');
    combat(0.25);
    const canD = TYPES.find(t=>t.id==='canhoneiro').dmg;
    console.assert(tgt.hp === hpC0-canD, 'Canhoneiro deve atirar após ~1.5s');
    state.units.length = 0;

    // Teste 8: Mosqueteiro parado não espera (sem mira)
    spawnUnit('left', 100, 120, TYPES.find(t=>t.id==='mosqueteiro'));
    spawnUnit('right', 200, 120, TYPES.find(t=>t.id==='scutum'));
    thinkTargets(0.016);
    let msq = state.units[0]; let tgt2 = state.units[1];
    msq.vx = 0; msq.vy = 0; msq.cooldown = 0; // parado
    const hpM0 = tgt2.hp; combat(0.016);
    const mosqD2 = TYPES.find(t=>t.id==='mosqueteiro').dmg;
    console.assert(tgt2.hp === hpM0-mosqD2, 'Mosqueteiro parado deve atirar imediatamente sem delay');
    state.units.length = 0;

    // Teste 9: Lanceiro em movimento não tem delay de mira (instantâneo)
    state.leftOffensive = true; state.rightOffensive = false;
    spawnUnit('left', 100, 120, TYPES.find(t=>t.id==='lanceiro'));
    spawnUnit('right', 220, 120, TYPES.find(t=>t.id==='scutum'));
    thinkTargets(0.016);
    let lan = state.units[0]; let tgt3 = state.units[1];
    // aproximar até entrar no alcance (80px)
    let gotIn=false;
    for(let i=0;i<100 && !gotIn;i++){ physics(0.05); const d=Math.hypot(tgt3.x-lan.x,tgt3.y-lan.y); if(d <= lan.range){ gotIn=true; lan.cooldown=0; break; } }
    const hpL0 = tgt3.hp; combat(0.016);
    console.assert(tgt3.hp === hpL0-20, 'Lanceiro não deve esperar mira; ataque imediato');
    state.units.length = 0;

    // Teste 10: Atirador realmente para durante a mira
    state.leftOffensive = true; state.rightOffensive = false;
    spawnUnit('left', 100, 120, TYPES.find(t=>t.id==='mosqueteiro'));
    spawnUnit('right', 420, 120, TYPES.find(t=>t.id==='scutum'));
    thinkTargets(0.016);
    shooter = state.units[0]; tgt = state.units[1]; entered=false;
    for(let i=0;i<200 && !entered;i++){ physics(0.05); const d=Math.hypot(tgt.x-shooter.x,tgt.y-shooter.y); if(d <= shooter.range){ entered=true; shooter.cooldown=0; break; } }
    // agora deve estar mirando; garantir que a velocidade ficou quase zero
    physics(0.05);
    const speedNow = Math.hypot(shooter.vx, shooter.vy);
    console.assert(speedNow < 2, 'Atirador deve ficar praticamente parado enquanto mira');
    state.units.length = 0;

    // Teste 11: Delay de mira não soma no cooldown
    state.leftOffensive = true; state.rightOffensive = false;
    spawnUnit('left', 100, 120, TYPES.find(t=>t.id==='mosqueteiro'));
    spawnUnit('right', 420, 120, TYPES.find(t=>t.id==='scutum'));
    thinkTargets(0.016);
    shooter = state.units[0]; tgt = state.units[1];
    // aproximar e iniciar mira
    entered=false;
    for(let i=0;i<200 && !entered;i++){ physics(0.05); const d=Math.hypot(tgt.x-shooter.x,tgt.y-shooter.y); if(d <= shooter.range){ entered=true; shooter.cooldown=0; break; } }
    // esperar ~1.5s até disparar
    let shot=false; let hpBefore=tgt.hp; const atkEvery = shooter.atkEvery;
    for(let t=0;t<2.0 && !shot;t+=0.01){ combat(0.01); if(tgt.hp < hpBefore){ shot=true; break; } }
    console.assert(Math.abs(shooter.cooldown - atkEvery) < 0.001, 'Cooldown deve ser igual a atkEvery após o tiro (sem somar o delay de mira)');
    state.units.length = 0;

    // Teste 12: Canhoneiro anda ~metade da velocidade do mosqueteiro
    state.leftOffensive = true; state.rightOffensive = false;
    spawnUnit('left', 100, 100, TYPES.find(t=>t.id==='canhoneiro'));
    spawnUnit('right', 900, 100, TYPES.find(t=>t.id==='scutum'));
    spawnUnit('left', 100, 200, TYPES.find(t=>t.id==='mosqueteiro'));
    spawnUnit('right', 900, 200, TYPES.find(t=>t.id==='scutum'));
    thinkTargets(0.016);
    let ch = state.units.find(u=>u.typeRef.id==='canhoneiro');
    let ms = state.units.find(u=>u.typeRef.id==='mosqueteiro');
    const x0ch = ch.x, x0ms = ms.x;
    for(let i=0;i<20;i++){ physics(0.05); }
    const vch = Math.abs(ch.x - x0ch);
    const vms = Math.abs(ms.x - x0ms);
    const ratio = vch / Math.max(1e-6, vms);
    console.assert(ratio > 0.4 && ratio < 0.6, 'Canhoneiro deve andar ~0.5x a velocidade do mosqueteiro');
    state.units.length = 0;

    // Teste 13: Elefante não é empurrado para trás por múltiplas unidades
    state.leftOffensive = false; state.rightOffensive = true; // elefante parado, inimigos avançando
    spawnUnit('left', 400, 140, TYPES.find(t=>t.id==='elefante'));
    spawnUnit('right', 430, 120, TYPES.find(t=>t.id==='guerreiro'));
    spawnUnit('right', 430, 140, TYPES.find(t=>t.id==='guerreiro'));
    spawnUnit('right', 430, 160, TYPES.find(t=>t.id==='guerreiro'));
    thinkTargets(0.016);
    let ele = state.units.find(u=>u.typeRef.id==='elefante');
    const x0 = ele.x;
    for(let i=0;i<80;i++){ physics(0.05); }
    console.assert(ele.x >= x0 - 2, 'Elefante não deve ser empurrado para trás significativamente');
    state.units.length = 0;

    // Teste 14: Elefante ataca até 2 inimigos simultaneamente no alcance melee
    state.leftOffensive = true; state.rightOffensive = false;
    spawnUnit('left', 300, 200, TYPES.find(t=>t.id==='elefante'));
    spawnUnit('right', 300 + 2*BASE_SIZE, 200 - 8, TYPES.find(t=>t.id==='scutum'));
    spawnUnit('right', 300 + 2*BASE_SIZE, 200 + 8, TYPES.find(t=>t.id==='scutum'));
    thinkTargets(0.016);
    let E = state.units.find(u=>u.typeRef.id==='elefante');
    // Garantir alcance corpo-a-corpo e atacar
    E.cooldown = 0; physics(0.016); combat(0.016);
    const twoDown = state.units.filter(u=>u.typeRef.id==='scutum' && u.dead).length;
    console.assert(twoDown >= 2, 'Elefante deve atingir (e provavelmente eliminar) dois alvos no melee');
    state.units.length = 0;


    // Teste 15: Cavalaria pesada acumula ~3s e aplica 3x dano no primeiro golpe
    spawnUnit('left', 100, 100, TYPES.find(t=>t.id==='cavalariaPesada'));
    spawnUnit('right', 400, 100, TYPES.find(t=>t.id==='scutum'));
    thinkTargets(0.016);
    for(let i=0;i<210;i++){ physics(0.015); } // ~3.15s de avanço
    let heavy = state.units[0]; let tgtH = state.units[1];
    heavy.x = tgtH.x - (heavy.rad + tgtH.rad) + 1; heavy.y = tgtH.y; heavy.cooldown = 0;
    thinkTargets(0.016); combat(0.016);
    console.assert(tgtH.hp === 35 - (15*3), 'Cavalaria pesada deve causar 3x dano após ~3s de aceleração');
    state.units.length = 0;

  }catch(err){
    console.error('Erro nos testes:', err);
  } finally {
    console.groupEnd();
    // restaurar estado
    state.started = save.started; state.units = save.units; state.projectiles = save.projectiles;
    state.leftOffensive = save.leftOffensive; state.rightOffensive = save.rightOffensive;
  }
}

// ======= INICIALIZAÇÃO =======
function init(){ buildTable(); resize(); requestAnimationFrame(loop); runUnitTests(); }
init();
</script>
</body>
</html>
