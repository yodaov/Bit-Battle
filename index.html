<!DOCTYPE html>
<html lang="pt-br">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Simulação de Guerras Medievais</title>
<style>
  :root{
    --bg:#0f1115; --panel:#171a21; --panel-2:#0c0f14; --text:#e7edf3; --muted:#9db0c3;
    --ok:#12b886; --danger:#fa5252; --line:#263141; --accent:#3b82f6;
    --table-h: 190px; /* altura da TABELA superior */
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Ubuntu,Arial,sans-serif;}
  header{background:linear-gradient(180deg,var(--panel),var(--panel-2));border-bottom:1px solid var(--line);} 
  h1{margin:0;padding:12px 16px;font-size:18px;letter-spacing:.3px}
  .wrap{display:flex;flex-direction:column;min-height:100vh}

  /* TABELA */
  .table-wrap{height:var(--table-h);padding:10px 12px;overflow:hidden}
  #troop-table{display:grid;grid-template-columns:repeat(12,minmax(90px,1fr));gap:8px;height:100%;}
  .tcell{background:#12151d;border:1px solid #1d2330;border-radius:10px;padding:8px;display:flex;flex-direction:column;align-items:center;justify-content:flex-start;user-select:none;position:relative}
  .tshape{width:44px;height:44px;margin:4px 0 6px 0;display:block}
  .tlabel{font-size:11px;line-height:1.15;text-align:center;color:var(--muted)}
  .tlabel b{color:var(--text)}
  .hint{position:absolute;right:6px;top:4px;font-size:10px;color:#7aa2c0}

  /* ARENA */
  .arena-wrap{position:relative;flex:1;display:flex;flex-direction:column;}
  .arena-topbar{position:absolute;left:0;right:0;top:0;display:flex;justify-content:space-between;pointer-events:none;padding:10px}
  .side-btn{pointer-events:auto;border:none;padding:10px 14px;border-radius:10px;font-weight:600;cursor:pointer;min-width:132px;box-shadow:0 6px 18px rgba(0,0,0,.25);}
  .offensive{background:rgba(18,184,134,.12);color:#a3f2d8;border:1px solid rgba(18,184,134,.35)}
  .defensive{background:rgba(250,82,82,.12);color:#ffb3b3;border:1px solid rgba(250,82,82,.35)}

  #arena{flex:1;background:radial-gradient(1200px 600px at 50% 30%, #0e1320 10%, #0a0e17 60%, #090c14 100%);border-top:1px solid var(--line)}

  /* FOOTER */
  footer{display:flex;justify-content:center;align-items:center;padding:12px;border-top:1px solid var(--line);background:var(--panel)}
  #startBtn{padding:12px 24px;border-radius:12px;border:1px solid #2b3550;background:linear-gradient(180deg,#2a3450,#1b2340);color:#def1ff;font-weight:700;letter-spacing:.3px;cursor:pointer;box-shadow:0 8px 25px rgba(0,0,0,.35)}
  #startBtn.playing{background:linear-gradient(180deg,#0b3d18,#073013);border-color:#0c6b37}

  /* OVERLAY DE FIM */
  .overlay{position:absolute;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.45);backdrop-filter:blur(2px)}
  .overlay .card{background:#101522;border:1px solid #202a40;border-radius:14px;padding:18px 20px;min-width:320px;text-align:center;box-shadow:0 10px 30px rgba(0,0,0,.45)}
  .overlay h2{margin:0 0 8px 0}
  .overlay p{margin:0 0 14px 0;color:var(--muted)}
  .overlay button{padding:10px 16px;border-radius:10px;border:1px solid #31406a;background:#162042;color:#dfe9ff;font-weight:600;cursor:pointer}

  /* Drag shape canvas overlay */
  #dragCanvas{position:fixed;left:0;top:0;pointer-events:none;z-index:40}

  /* Responsivo simples */
  @media (max-width:1200px){
    #troop-table{grid-template-columns:repeat(6,minmax(90px,1fr));}
  }
.credit{position:absolute;right:12px;bottom:12px;font-size:12px;color:#7aa2c0;opacity:.7;pointer-events:none}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>Simulação de Guerras Medievais — Arraste tropas da <b>Tabela</b> para a <b>Arena</b> (esquerda ou direita)</h1>
  </header>

  <div class="table-wrap">
    <div id="troop-table"></div>
  </div>

  <div class="arena-wrap">
    <canvas id="arena"></canvas>
    <div class="arena-topbar">
      <button id="leftMode" class="side-btn offensive" aria-pressed="true">Ofensivo (Esquerda)</button>
      <button id="rightMode" class="side-btn offensive" aria-pressed="true">Ofensivo (Direita)</button>
    </div>
    <div class="credit">yodaov</div>
    <div id="endOverlay" class="overlay">
      <div class="card">
        <h2 id="endTitle">Fim de batalha</h2>
        <p id="endSubtitle">—</p>
        <button id="resetBtn">Recomeçar</button>
      </div>
    </div>
  </div>

  <footer>
    <button id="startBtn">Começar</button>
  </footer>
</div>

<canvas id="dragCanvas" width="1" height="1"></canvas>

<script>
// ======= DEFINIÇÕES DAS TROPAS =======
const BASE_SIZE = 16; // px
const SPEED = 70;     // velocidade base px/s
const JITTER = 0.0005; // ruído mínimo p/ evitar pendular

// Definição por tipo
// shape: 'square' | 'triangle' | 'circle' | 'pentagon'
const TYPES = [
  { id:'soldado',      name:'Soldado',       color:'#ff3b30', shape:'square',   sizeMul:1,  hp:10, dmg:5,  atkEvery:2,  rangeMul:0,   melee:true },
  { id:'arqueiro',     name:'Arqueiro',      color:'#ffd43b', shape:'triangle', sizeMul:1,  hp:10, dmg:10, atkEvery:6,  rangeMul:20,  melee:false },
  { id:'arqueiroElite',name:'Arqueiro elite',color:'#1b5e20', shape:'triangle', sizeMul:1,  hp:10, dmg:15, atkEvery:4,  rangeMul:30,  melee:false },
  { id:'guerreiro',    name:'Guerreiro',     color:'#515151', shape:'square',   sizeMul:1,  hp:22, dmg:10, atkEvery:3,  rangeMul:0,   melee:true },
  { id:'scutum',       name:'Scutum',        color:'#ff3b30', shape:'circle',   sizeMul:1,  hp:35, dmg:2,  atkEvery:3,  rangeMul:0,   melee:true },
  { id:'lanceiro',     name:'Lanceiro',      color:'#ff922b', shape:'square',   sizeMul:1,  hp:5, dmg:10,  atkEvery:4,  rangeMul:5,   melee:false },
  { id:'elefante',     name:'Elefante',      color:'#8C8C8C', shape:'circle',   sizeMul:2,  hp:80, dmg:40, atkEvery:8,  rangeMul:0,   melee:true },
  { id:'mosqueteiro',  name:'Mosqueteiro',   color:'#1D44B8', shape:'circle',   sizeMul:1,  hp:10, dmg:50, atkEvery:20, rangeMul:15,  melee:false },
  { id:'general',      name:'General',       color:'#FFD700', shape:'pentagon', sizeMul:1,  hp:40, dmg:20, atkEvery:2,  rangeMul:0,   melee:true },
  { id:'canhoneiro',   name:'Canhoneiro',    color:'#000000', shape:'square',   sizeMul:1,  hp:20, dmg:100,atkEvery:40, rangeMul:35,  melee:false },
  { id:'armaEspada',   name:'Arma-espada',   color:'#7ec8e3', shape:'triangle', sizeMul:1,  hp:10, dmg:50, atkEvery:20, rangeMul:15,  melee:false, phase:'mosqueteiro' },
  { id:'viking',       name:'Viking',        color:'#7a5230', shape:'square',   sizeMul:1,  hp:10, dmg:15, atkEvery:2,  rangeMul:0,   melee:true },
];

// Soldado stats para arma-espada fase 2
const SOLDIER_STATS = { hp:10, dmg:5, atkEvery:2, rangeMul:0, melee:true };

// ======= SISTEMA =======
const arena = document.getElementById('arena');
const ctx = arena.getContext('2d');
const dragCanvas = document.getElementById('dragCanvas');
const dctx = dragCanvas.getContext('2d');
const table = document.getElementById('troop-table');
const startBtn = document.getElementById('startBtn');
const leftModeBtn = document.getElementById('leftMode');
const rightModeBtn = document.getElementById('rightMode');
const endOverlay = document.getElementById('endOverlay');
const endTitle = document.getElementById('endTitle');
const endSubtitle = document.getElementById('endSubtitle');
const resetBtn = document.getElementById('resetBtn');

let state = {
  started:false,
  lastTime:0,
  w:0,h:0,
  leftOffensive:true,
  rightOffensive:true,
  units:[], // {id,x,y,vx,vy,team,typeRef,rad,hp,maxHp,dmg,atkEvery,range,melee,cooldown,dead,fade,phase}
  projectiles:[], // efeitos visuais simples (linhas curtas)
};

let drag = {
  active:false, type:null, x:0, y:0
};
let nextUnitId = 1;

function resize(){
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  const rect = arena.getBoundingClientRect();
  state.w = rect.width; state.h = rect.height;
  arena.width = Math.floor(rect.width * dpr);
  arena.height = Math.floor(rect.height * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize', resize);

// Construir TABELA de tropas
function buildTable(){
  table.innerHTML = '';
  TYPES.forEach(t => {
    const cell = document.createElement('div');
    cell.className = 'tcell';
    const canv = document.createElement('canvas');
    canv.width = 44; canv.height = 44; canv.className='tshape';
    drawShape(canv.getContext('2d'), 22,22, BASE_SIZE*t.sizeMul*0.9, t.shape, t.color);

    const lab = document.createElement('div'); lab.className='tlabel';
    lab.innerHTML = `<b>${t.name}</b><br>Vida ${t.hp} • Dano ${t.dmg}`;

    cell.appendChild(canv);
    cell.appendChild(lab);

    // tornar "arrastável" (nosso próprio DnD)
    cell.addEventListener('pointerdown', e=>startDrag(e,t));

    table.appendChild(cell);
  });
}

// Desenhar formas no canvas
function drawShape(g, cx, cy, size, shape, color){
  g.save();
  g.fillStyle = color; g.strokeStyle = '#ffffff25'; g.lineWidth = 1.5;
  if(shape==='square'){
    g.beginPath(); g.rect(cx-size, cy-size, size*2, size*2); g.fill(); g.stroke();
  }else if(shape==='circle'){
    g.beginPath(); g.arc(cx,cy,size,0,Math.PI*2); g.fill(); g.stroke();
  }else if(shape==='triangle'){
    const h = size*1.6; // um triângulo um pouco alto
    g.beginPath();
    g.moveTo(cx, cy-h/2);
    g.lineTo(cx-size, cy+h/2);
    g.lineTo(cx+size, cy+h/2);
    g.closePath(); g.fill(); g.stroke();
  }else if(shape==='pentagon'){
    g.beginPath();
    const n=5; const r=size; const rot=-Math.PI/2;
    for(let i=0;i<n;i++){
      const a = rot + i*2*Math.PI/n;
      const x = cx + Math.cos(a)*r;
      const y = cy + Math.sin(a)*r;
      if(i===0) g.moveTo(x,y); else g.lineTo(x,y);
    }
    g.closePath(); g.fill(); g.stroke();
  }
  g.restore();
}

function startDrag(e, type){
  drag.active = true; drag.type = type; 
  drag.x = e.clientX; drag.y = e.clientY; 
  if(e.target.setPointerCapture){ try{ e.target.setPointerCapture(e.pointerId); }catch(err){} }
  dragCanvas.style.display = 'block';
  updateDragCanvas();
  window.addEventListener('pointermove', onDragMove);
  window.addEventListener('pointerup', onDragEnd, {once:true});
}
function onDragMove(e){ drag.x = e.clientX; drag.y = e.clientY; updateDragCanvas(); }
function updateDragCanvas(){
  if(!drag.active || !drag.type) { dragCanvas.style.display='none'; dragCanvas.width=1; dragCanvas.height=1; return; }
  const size = BASE_SIZE*drag.type.sizeMul*1.2;
  dragCanvas.width = size*2+6; dragCanvas.height = size*2+6;
  // posição absoluta na viewport (elemento position:fixed)
  dragCanvas.style.transform = `translate(${drag.x - size - 3}px, ${drag.y - size - 3}px)`;
  const g = dctx; g.clearRect(0,0,dragCanvas.width,dragCanvas.height);
  drawShape(g, dragCanvas.width/2, dragCanvas.height/2, size, drag.type.shape, drag.type.color);
}
function onDragEnd(e){
  window.removeEventListener('pointermove', onDragMove);
  // Verificar se soltou dentro da ARENA
  const aRect = arena.getBoundingClientRect();
  if(e.clientY >= aRect.top && e.clientY <= aRect.bottom){
    const x = e.clientX - aRect.left; const y = e.clientY - aRect.top;
    const team = (x < aRect.width/2) ? 'left' : 'right';
    spawnUnit(team, x, y, drag.type);
  }
  drag.active=false; drag.type=null; dragCanvas.style.display='none'; updateDragCanvas();
}

function spawnUnit(team, x, y, t){
  const rad = BASE_SIZE * t.sizeMul;
  const u = {
    id: nextUnitId++, team, x, y, vx:0, vy:0, 
    typeRef: t, rad, color: t.color, shape: t.shape,
    hp: t.hp, maxHp:t.hp, dmg: t.dmg, atkEvery: t.atkEvery, range: t.rangeMul*BASE_SIZE, melee: t.melee,
    cooldown: 0, dead:false, fade:0, targetId:null, lastDist:null, noProgressT:0, phase:t.phase||null
  };
  // Pequena nudged para evitar sobreposição forte no spawn
  const jitter = (Math.random()-.5)*4;
  u.x += jitter; u.y += jitter;
  state.units.push(u);
}

// ======= BOTÕES =======
leftModeBtn.addEventListener('click', ()=>{
  state.leftOffensive = !state.leftOffensive;
  applyModeBtn(leftModeBtn, state.leftOffensive, 'Esquerda');
});
rightModeBtn.addEventListener('click', ()=>{
  state.rightOffensive = !state.rightOffensive;
  applyModeBtn(rightModeBtn, state.rightOffensive, 'Direita');
});
function applyModeBtn(btn, isOff, sideText){
  btn.classList.toggle('offensive', isOff);
  btn.classList.toggle('defensive', !isOff);
  btn.setAttribute('aria-pressed', String(isOff));
  btn.textContent = (isOff? 'Ofensivo':'Defensivo') + ` (${sideText})`;
}

startBtn.addEventListener('click', ()=>{
  if(!state.started){
    state.started = true; startBtn.classList.add('playing'); startBtn.textContent='Em batalha';
  }
});
resetBtn.addEventListener('click', resetBattle);

function resetBattle(){
  endOverlay.style.display='none';
  state.units.length=0; state.projectiles.length=0;
  state.started=false; startBtn.classList.remove('playing'); startBtn.textContent='Começar';
  state.leftOffensive=true; state.rightOffensive=true;
  applyModeBtn(leftModeBtn,true,'Esquerda');
  applyModeBtn(rightModeBtn,true,'Direita');
}

// ======= GAME LOOP =======
function loop(ts){
  if(!state.lastTime) state.lastTime = ts;
  const dt = Math.min(0.05, (ts - state.lastTime)/1000); // cap dt
  state.lastTime = ts;

  update(dt);
  render();
  requestAnimationFrame(loop);
}

function update(dt){
  // Não mover tropas antes do começo
  if(state.started){
    thinkTargets(dt);
    physics(dt);
    combat(dt);
    cleanup();
    checkEnd();
  }
}

function thinkTargets(dt){
  // Atualiza alvo mais próximo periodicamente
  for(const u of state.units){ if(u.dead) continue;
    // se não há inimigos, fica sem target
    const enemies = state.units.filter(v=>!v.dead && v.team!==u.team);
    if(enemies.length===0){ u.targetId=null; continue; }
    // Escolher alvo mais próximo
    let best=null, bestD=Infinity;
    for(const v of enemies){
      const dx=v.x-u.x, dy=v.y-u.y; const d = Math.hypot(dx,dy);
      if(d<bestD){ best=v; bestD=d; }
    }
    u.targetId = best? best.id : null;
  }
}

function physics(dt){
  // Movimento com steering (seek + separation) e resolução de colisão
  // 1) Integração de velocidade
  for(const u of state.units){ if(u.dead) continue;
    const target = state.units.find(v=>v.id===u.targetId);

    const isOffensive = (u.team==='left') ? state.leftOffensive : state.rightOffensive;

    let desiredX=0, desiredY=0;
    if(isOffensive && target){
      // Checar alcance
      const dx = target.x - u.x; const dy = target.y - u.y; const dist = Math.hypot(dx,dy);
      const inRange = u.melee ? (dist <= u.rad + target.rad + 1.5) : (dist <= u.range);
      if(!inRange){
        // vetor em direção ao alvo
        if(dist>0.0001){ desiredX += dx/dist; desiredY += dy/dist; }
      }
      // Progresso para não ficar preso
      if(u.lastDist==null) u.lastDist = dist;
      if(dist < u.lastDist - 0.5) { u.noProgressT=0; } else { u.noProgressT += dt; }
      u.lastDist = dist;
      if(u.noProgressT > 1.2 && isOffensive){ // tentar escapar
        // adicionar componente lateral
        const perpX = -dy/(dist||1), perpY = dx/(dist||1);
        const side = (Math.random()<0.5? -1:1);
        desiredX += perpX*0.8*side; desiredY += perpY*0.8*side; 
        u.noProgressT = 0.6; // reduz e tenta de novo
      }
    }

    // separação para evitar engarrafamentos
    let sepX=0, sepY=0; let n=0;
    for(const v of state.units){ if(v===u || v.dead) continue; 
      const dx=u.x-v.x, dy=u.y-v.y; const d=Math.hypot(dx,dy); const minD=u.rad+v.rad+2;
      if(d<minD && d>0.0001){
        const push=(minD-d)/minD; sepX += (dx/d)*push; sepY += (dy/d)*push; n++;
      }
    }
    if(n>0){ sepX/=n; sepY/=n; }

    // Combinar
    let vx = desiredX*1.0 + sepX*1.6; 
    let vy = desiredY*1.0 + sepY*1.6;

    // Normalizar
    const mag = Math.hypot(vx,vy) + JITTER;
    const maxV = SPEED * (u.rad/BASE_SIZE <= 1 ? 1 : 0.7); // elefante mais lento
    let tx = vx/mag * maxV; let ty = vy/mag * maxV;

    // amortecimento suave para movimento natural
    const smooth = 0.14;
    if(!state.started || !( (u.team==='left'?state.leftOffensive:state.rightOffensive) )){ tx=0; ty=0; }
    u.vx = u.vx*(1-smooth) + tx*smooth;
    u.vy = u.vy*(1-smooth) + ty*smooth;
  }

  // 2) Atualizar posição
  for(const u of state.units){ if(u.dead) continue; u.x += u.vx*dt; u.y += u.vy*dt; }

  // 3) Resolver colisões de sobreposição (empurrão) — não atravessar
  for(let i=0;i<state.units.length;i++){
    const a=state.units[i]; if(a.dead) continue;
    for(let j=i+1;j<state.units.length;j++){
      const b=state.units[j]; if(b.dead) continue;
      let dx=b.x-a.x, dy=b.y-a.y; let d=Math.hypot(dx,dy);
      const minD = a.rad + b.rad + 0.5;
      if(d<minD && d>0){
        const overlap = (minD-d)/2;
        const nx = dx/d, ny = dy/d;
        a.x -= nx*overlap; a.y -= ny*overlap;
        b.x += nx*overlap; b.y += ny*overlap;
      }
    }
  }

  // 4) Limites da arena
  const pad = 6;
  for(const u of state.units){ if(u.dead) continue;
    u.x = Math.max(pad+u.rad, Math.min(state.w - pad - u.rad, u.x));
    u.y = Math.max(12+u.rad, Math.min(state.h - pad - u.rad, u.y));
  }
}

function combat(dt){
  for(const u of state.units){ if(u.dead) continue;
    if(u.cooldown>0) u.cooldown -= dt;
    const target = state.units.find(v=>v.id===u.targetId);
    if(!target || target.dead) continue;
    const dx = target.x - u.x; const dy = target.y - u.y; const dist = Math.hypot(dx,dy);
    const inRange = u.melee ? (dist <= u.rad + target.rad + 1.5) : (dist <= u.range);
    if(inRange && u.cooldown<=0){
      // Arma-espada: primeiro ataque como mosqueteiro, depois vira soldado (melee)
      if(u.typeRef.id==='armaEspada' && u.phase!=='soldado' && !u.melee){
        // primeiro ataque à distância
        target.hp -= u.dmg;
        state.projectiles.push({x1:u.x, y1:u.y, x2:target.x, y2:target.y, t:0.18, color:'#a7d3ff'});
        // troca de fase para soldado (melee)
        u.dmg = SOLDIER_STATS.dmg;
        u.atkEvery = SOLDIER_STATS.atkEvery;
        u.range = 0;
        u.melee = true;
        u.phase = 'soldado';
        // reinicia cooldown para o ciclo de soldado (evita ficar preso com 20s do mosqueteiro)
        u.cooldown = SOLDIER_STATS.atkEvery;
      } else {
        // ataque normal
        target.hp -= u.dmg;
        u.cooldown = u.atkEvery;
        if(!u.melee){
          state.projectiles.push({x1:u.x, y1:u.y, x2:target.x, y2:target.y, t:0.18, color:'#a7d3ff'});
        }
      }
      if(target.hp<=0 && !target.dead){ target.dead=true; target.fade=0.8; target.vx=0; target.vy=0; }
    }
  }

  // atualizar efeitos de projéteis
  state.projectiles = state.projectiles.filter(p=> (p.t-=dt) > 0);

  // fade de mortos
  for(const u of state.units){ if(!u.dead) continue; u.fade -= dt; }
}

function cleanup(){
  // Remover completamente os que sumiram
  state.units = state.units.filter(u=> !(u.dead && u.fade<=0));
}

function checkEnd(){
  const leftAlive = state.units.some(u=>!u.dead && u.team==='left');
  const rightAlive = state.units.some(u=>!u.dead && u.team==='right');
  if(!leftAlive || !rightAlive){
    const winner = leftAlive? 'Esquerda' : rightAlive? 'Direita' : 'Empate';
    endTitle.textContent = `Vitória: ${winner}`;
    const l = state.units.filter(u=>u.team==='left').length;
    const r = state.units.filter(u=>u.team==='right').length;
    endSubtitle.textContent = `Unidades restantes — Esquerda: ${l} • Direita: ${r}`;
    endOverlay.style.display='flex';
  }
}

function render(){
  ctx.clearRect(0,0,state.w,state.h);
  // linha central
  ctx.save();
  ctx.strokeStyle = '#21304a'; ctx.lineWidth = 2; ctx.setLineDash([8,8]);
  ctx.beginPath(); ctx.moveTo(state.w/2, 0); ctx.lineTo(state.w/2, state.h); ctx.stroke();
  ctx.restore();

  // desenhar unidades (mortos no fundo com alpha menor)
  const sorted = [...state.units].sort((a,b)=> (a.dead?0:1)-(b.dead?0:1));
  for(const u of sorted){
    const alpha = u.dead ? Math.max(0,u.fade) : 1;
    ctx.save(); ctx.globalAlpha = alpha;
    drawShape(ctx, u.x, u.y, u.rad, u.shape, u.color);
    // barra de vida
    if(!u.dead){
      const w = u.rad*1.8; const h=4; const x=u.x-w/2, y=u.y+u.rad+6;
      ctx.fillStyle='#0b1220'; ctx.fillRect(x,y,w,h);
      ctx.fillStyle='#1dd1a1'; ctx.fillRect(x,y,w*(u.hp/Math.max(1,u.maxHp)),h);
      ctx.strokeStyle='#00000055'; ctx.strokeRect(x,y,w,h);
    }
    ctx.restore();
  }

  // projéteis (linhas rápidas)
  for(const p of state.projectiles){
    ctx.save(); ctx.globalAlpha = Math.max(0,p.t/0.18);
    ctx.strokeStyle = p.color; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(p.x1,p.y1); ctx.lineTo(p.x2,p.y2); ctx.stroke(); ctx.restore();
  }
}

// ======= INICIALIZAÇÃO =======
function init(){ buildTable(); resize(); requestAnimationFrame(loop); }
init();
</script>
</body>
</html>
